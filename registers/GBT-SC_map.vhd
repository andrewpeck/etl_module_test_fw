--This file was auto-generated.
--Modifications might be lost.
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.AXIRegPkg.all;
use work.types.all;
use work.GBT-SC_Ctrl.all;
entity GBT-SC_interface is
  port (
    clk_axi          : in  std_logic;
    reset_axi_n      : in  std_logic;
    slave_readMOSI   : in  AXIReadMOSI;
    slave_readMISO   : out AXIReadMISO  := DefaultAXIReadMISO;
    slave_writeMOSI  : in  AXIWriteMOSI;
    slave_writeMISO  : out AXIWriteMISO := DefaultAXIWriteMISO;
    Mon              : in  GBT-SC_Mon_t;
    Ctrl             : out GBT-SC_Ctrl_t
    );
end entity GBT-SC_interface;
architecture behavioral of GBT-SC_interface is
  signal localAddress       : slv_32_t;
  signal localRdData        : slv_32_t;
  signal localRdData_latch  : slv_32_t;
  signal localWrData        : slv_32_t;
  signal localWrEn          : std_logic;
  signal localRdReq         : std_logic;
  signal localRdAck         : std_logic;


  signal reg_data :  slv32_array_t(integer range 0 to 40);
  constant Default_reg_data : slv32_array_t(integer range 0 to 40) := (others => x"00000000");
begin  -- architecture behavioral

  -------------------------------------------------------------------------------
  -- AXI 
  -------------------------------------------------------------------------------
  -------------------------------------------------------------------------------
  AXIRegBridge : entity work.axiLiteReg
    port map (
      clk_axi     => clk_axi,
      reset_axi_n => reset_axi_n,
      readMOSI    => slave_readMOSI,
      readMISO    => slave_readMISO,
      writeMOSI   => slave_writeMOSI,
      writeMISO   => slave_writeMISO,
      address     => localAddress,
      rd_data     => localRdData_latch,
      wr_data     => localWrData,
      write_en    => localWrEn,
      read_req    => localRdReq,
      read_ack    => localRdAck);

  latch_reads: process (clk_axi) is
  begin  -- process latch_reads
    if clk_axi'event and clk_axi = '1' then  -- rising clock edge
      if localRdReq = '1' then
        localRdData_latch <= localRdData;        
      end if;
    end if;
  end process latch_reads;
  reads: process (localRdReq,localAddress,reg_data) is
  begin  -- process reads
    localRdAck  <= '0';
    localRdData <= x"00000000";
    if localRdReq = '1' then
      localRdAck  <= '1';
      case to_integer(unsigned(localAddress(5 downto 0))) is

        when 2 => --0x2
          localRdData( 0)            <=  reg_data( 2)( 0);                     --Request a write config to the GBTx (IC)
          localRdData( 1)            <=  reg_data( 2)( 1);                     --Request a read config to the GBTx (IC)
          localRdData(15 downto  8)  <=  reg_data( 2)(15 downto  8);           --I2C address of the GBTx
        when 8 => --0x8
          localRdData( 0)            <=  Mon.MASTER.TX_READY;                  --IC core ready for a transaction
          localRdData( 1)            <=  Mon.MASTER.RX_EMPTY;                  --Rx FIFO is empty (no reply from GBTx)
        when 21 => --0x15
          localRdData( 2 downto  0)  <=  reg_data(21)( 2 downto  0);           --Enable flag to select SCAs
        when 5 => --0x5
          localRdData( 7 downto  0)  <=  reg_data( 5)( 7 downto  0);           --Data to be written into the internal FIFO
          localRdData(15 downto  8)  <=  Mon.MASTER.RX_DATA_FROM_GBTX;         --Data from the FIFO
        when 9 => --0x9
          localRdData( 7 downto  0)  <=  reg_data( 9)( 7 downto  0);           --Command: The Command field is present in the frames received by the SCA and indicates the operation to be performed. Meaning is specific to the channel.
          localRdData(15 downto  8)  <=  reg_data( 9)(15 downto  8);           --Command: It represents the packet destination address. The address is one-byte long. By default, the GBT-SCA use address 0x00.
          localRdData(23 downto 16)  <=  reg_data( 9)(23 downto 16);           --Command: Specifies the message identification number. The reply messages generated by the SCA have the same transaction identifier of the request message allowing to associate the transmitted commands with the corresponding replies, permitting the concurrent use of all the SCA channels.  It is not required that ID values are ordered. ID values 0x00 and 0xff are reserved for interrupt packets generated spontaneously by the SCA and should not be used in requests.
          localRdData(31 downto 24)  <=  reg_data( 9)(31 downto 24);           --Command: The channel field specifies the destination interface of the request message (ctrl/spi/gpio/i2c/jtag/adc/dac).
        when 3 => --0x3
          localRdData(31 downto 16)  <=  reg_data( 3)(31 downto 16);           --Address of the first register to be accessed
        when 4 => --0x4
          localRdData(31 downto 16)  <=  reg_data( 4)(31 downto 16);           --Number of words/bytes to be read (only for read transactions)
        when 10 => --0xa
          localRdData(31 downto  0)  <=  reg_data(10)(31 downto  0);           --Command: data field (According to the SCA manual)
        when 11 => --0xb
          localRdData( 7 downto  0)  <=  Mon.MASTER.RX.RX(0).RX_LEN;           --Reply: The length qualifier field specifies the number of bytes contained in the DATA field.
          localRdData(15 downto  8)  <=  Mon.MASTER.RX.RX(0).RX_ADDRESS;       --Reply: It represents the packet destination address. The address is one-bytelong. By default, the GBT-SCA use address 0x00.
          localRdData(23 downto 16)  <=  Mon.MASTER.RX.RX(0).RX_CONTROL;       --Reply: The control field is 1 byte in length and contains frame sequence numbers of the currently transmitted frame and the last correctly received frame. The control field is also used to convey three supervisory level commands: Connect, Reset, and Test.
          localRdData(31 downto 24)  <=  Mon.MASTER.RX.RX(0).RX_TRANSID;       --Reply: transaction ID field (According to the SCA manual)
        when 12 => --0xc
          localRdData( 7 downto  0)  <=  Mon.MASTER.RX.RX(0).RX_ERR;           --Reply: The Error Flag field is present in the channel reply frames to indicate error conditions encountered in the execution of a command. If no errors are found, its value is 0x00.
          localRdData( 8)            <=  Mon.MASTER.RX.RX(0).RX_RECEIVED;      --Reply received flag (pulse)
          localRdData(19 downto 12)  <=  Mon.MASTER.RX.RX(0).RX_CHANNEL;       --Reply: The channel field specifies the destination interface of the request message (ctrl/spi/gpio/i2c/jtag/adc/dac).
        when 13 => --0xd
          localRdData(31 downto  0)  <=  Mon.MASTER.RX.RX(0).RX_DATA;          --Reply: The Data field is command dependent field whose length is defined by the length qualifier field. For example, in the case of a read/write operation on a GBT-SCA internal register, it contains the value written/read from the register.
        when 14 => --0xe
          localRdData( 7 downto  0)  <=  Mon.MASTER.RX.RX(1).RX_LEN;           --Reply: The length qualifier field specifies the number of bytes contained in the DATA field.
          localRdData(15 downto  8)  <=  Mon.MASTER.RX.RX(1).RX_ADDRESS;       --Reply: It represents the packet destination address. The address is one-bytelong. By default, the GBT-SCA use address 0x00.
          localRdData(23 downto 16)  <=  Mon.MASTER.RX.RX(1).RX_CONTROL;       --Reply: The control field is 1 byte in length and contains frame sequence numbers of the currently transmitted frame and the last correctly received frame. The control field is also used to convey three supervisory level commands: Connect, Reset, and Test.
          localRdData(31 downto 24)  <=  Mon.MASTER.RX.RX(1).RX_TRANSID;       --Reply: transaction ID field (According to the SCA manual)
        when 15 => --0xf
          localRdData( 7 downto  0)  <=  Mon.MASTER.RX.RX(1).RX_ERR;           --Reply: The Error Flag field is present in the channel reply frames to indicate error conditions encountered in the execution of a command. If no errors are found, its value is 0x00.
          localRdData( 8)            <=  Mon.MASTER.RX.RX(1).RX_RECEIVED;      --Reply received flag (pulse)
          localRdData(19 downto 12)  <=  Mon.MASTER.RX.RX(1).RX_CHANNEL;       --Reply: The channel field specifies the destination interface of the request message (ctrl/spi/gpio/i2c/jtag/adc/dac).
        when 16 => --0x10
          localRdData(31 downto  0)  <=  Mon.MASTER.RX.RX(1).RX_DATA;          --Reply: The Data field is command dependent field whose length is defined by the length qualifier field. For example, in the case of a read/write operation on a GBT-SCA internal register, it contains the value written/read from the register.
        when 17 => --0x11
          localRdData( 7 downto  0)  <=  Mon.MASTER.RX.RX(2).RX_LEN;           --Reply: The length qualifier field specifies the number of bytes contained in the DATA field.
          localRdData(15 downto  8)  <=  Mon.MASTER.RX.RX(2).RX_ADDRESS;       --Reply: It represents the packet destination address. The address is one-bytelong. By default, the GBT-SCA use address 0x00.
          localRdData(23 downto 16)  <=  Mon.MASTER.RX.RX(2).RX_CONTROL;       --Reply: The control field is 1 byte in length and contains frame sequence numbers of the currently transmitted frame and the last correctly received frame. The control field is also used to convey three supervisory level commands: Connect, Reset, and Test.
          localRdData(31 downto 24)  <=  Mon.MASTER.RX.RX(2).RX_TRANSID;       --Reply: transaction ID field (According to the SCA manual)
        when 18 => --0x12
          localRdData( 7 downto  0)  <=  Mon.MASTER.RX.RX(2).RX_ERR;           --Reply: The Error Flag field is present in the channel reply frames to indicate error conditions encountered in the execution of a command. If no errors are found, its value is 0x00.
          localRdData( 8)            <=  Mon.MASTER.RX.RX(2).RX_RECEIVED;      --Reply received flag (pulse)
          localRdData(19 downto 12)  <=  Mon.MASTER.RX.RX(2).RX_CHANNEL;       --Reply: The channel field specifies the destination interface of the request message (ctrl/spi/gpio/i2c/jtag/adc/dac).
        when 19 => --0x13
          localRdData(31 downto  0)  <=  Mon.MASTER.RX.RX(2).RX_DATA;          --Reply: The Data field is command dependent field whose length is defined by the length qualifier field. For example, in the case of a read/write operation on a GBT-SCA internal register, it contains the value written/read from the register.
        when 34 => --0x22
          localRdData( 0)            <=  reg_data(34)( 0);                     --Request a write config to the GBTx (IC)
          localRdData( 1)            <=  reg_data(34)( 1);                     --Request a read config to the GBTx (IC)
          localRdData(15 downto  8)  <=  reg_data(34)(15 downto  8);           --I2C address of the GBTx
        when 40 => --0x28
          localRdData( 0)            <=  Mon.SLAVE.TX_READY;                   --IC core ready for a transaction
          localRdData( 1)            <=  Mon.SLAVE.RX_EMPTY;                   --Rx FIFO is empty (no reply from GBTx)
        when 37 => --0x25
          localRdData( 7 downto  0)  <=  reg_data(37)( 7 downto  0);           --Data to be written into the internal FIFO
          localRdData(15 downto  8)  <=  Mon.SLAVE.RX_DATA_FROM_GBTX;          --Data from the FIFO
        when 35 => --0x23
          localRdData(31 downto 16)  <=  reg_data(35)(31 downto 16);           --Address of the first register to be accessed
        when 36 => --0x24
          localRdData(31 downto 16)  <=  reg_data(36)(31 downto 16);           --Number of words/bytes to be read (only for read transactions)


        when others =>
          localRdData <= x"00000000";
      end case;
    end if;
  end process reads;




  -- Register mapping to ctrl structures
  Ctrl.MASTER.TX_START_WRITE        <=  reg_data( 2)( 0);               
  Ctrl.MASTER.TX_START_READ         <=  reg_data( 2)( 1);               
  Ctrl.MASTER.SCA_ENABLE            <=  reg_data(21)( 2 downto  0);     
  Ctrl.MASTER.TX_DATA_TO_GBTX       <=  reg_data( 5)( 7 downto  0);     
  Ctrl.MASTER.TX_CMD                <=  reg_data( 9)( 7 downto  0);     
  Ctrl.MASTER.TX_GBTX_ADDR          <=  reg_data( 2)(15 downto  8);     
  Ctrl.MASTER.TX_ADDRESS            <=  reg_data( 9)(15 downto  8);     
  Ctrl.MASTER.TX_TRANSID            <=  reg_data( 9)(23 downto 16);     
  Ctrl.MASTER.TX_CHANNEL            <=  reg_data( 9)(31 downto 24);     
  Ctrl.MASTER.TX_REGISTER_ADDR      <=  reg_data( 3)(31 downto 16);     
  Ctrl.MASTER.TX_NUM_BYTES_TO_READ  <=  reg_data( 4)(31 downto 16);     
  Ctrl.MASTER.TX_DATA               <=  reg_data(10)(31 downto  0);     
  Ctrl.SLAVE.TX_START_WRITE         <=  reg_data(34)( 0);               
  Ctrl.SLAVE.TX_START_READ          <=  reg_data(34)( 1);               
  Ctrl.SLAVE.TX_DATA_TO_GBTX        <=  reg_data(37)( 7 downto  0);     
  Ctrl.SLAVE.TX_GBTX_ADDR           <=  reg_data(34)(15 downto  8);     
  Ctrl.SLAVE.TX_REGISTER_ADDR       <=  reg_data(35)(31 downto 16);     
  Ctrl.SLAVE.TX_NUM_BYTES_TO_READ   <=  reg_data(36)(31 downto 16);     


  reg_writes: process (clk_axi, reset_axi_n) is
  begin  -- process reg_writes
    if reset_axi_n = '0' then                 -- asynchronous reset (active low)
      reg_data( 2)( 0)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_START_WRITE;
      reg_data( 2)( 1)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_START_READ;
      reg_data(21)( 2 downto  0)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.SCA_ENABLE;
      reg_data( 5)( 7 downto  0)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_DATA_TO_GBTX;
      reg_data( 9)( 7 downto  0)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_CMD;
      reg_data( 2)(15 downto  8)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_GBTX_ADDR;
      reg_data( 9)(15 downto  8)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_ADDRESS;
      reg_data( 9)(23 downto 16)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_TRANSID;
      reg_data( 9)(31 downto 24)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_CHANNEL;
      reg_data( 3)(31 downto 16)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_REGISTER_ADDR;
      reg_data( 4)(31 downto 16)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_NUM_BYTES_TO_READ;
      reg_data(10)(31 downto  0)  <= DEFAULT_GBT-SC_CTRL_t.MASTER.TX_DATA;
      reg_data(34)( 0)  <= DEFAULT_GBT-SC_CTRL_t.SLAVE.TX_START_WRITE;
      reg_data(34)( 1)  <= DEFAULT_GBT-SC_CTRL_t.SLAVE.TX_START_READ;
      reg_data(37)( 7 downto  0)  <= DEFAULT_GBT-SC_CTRL_t.SLAVE.TX_DATA_TO_GBTX;
      reg_data(34)(15 downto  8)  <= DEFAULT_GBT-SC_CTRL_t.SLAVE.TX_GBTX_ADDR;
      reg_data(35)(31 downto 16)  <= DEFAULT_GBT-SC_CTRL_t.SLAVE.TX_REGISTER_ADDR;
      reg_data(36)(31 downto 16)  <= DEFAULT_GBT-SC_CTRL_t.SLAVE.TX_NUM_BYTES_TO_READ;

    elsif clk_axi'event and clk_axi = '1' then  -- rising clock edge
      Ctrl.MASTER.TX_RESET <= '0';
      Ctrl.MASTER.RX_RESET <= '0';
      Ctrl.MASTER.TX_WR <= '0';
      Ctrl.MASTER.RX_RD <= '0';
      Ctrl.MASTER.START_RESET <= '0';
      Ctrl.MASTER.START_CONNECT <= '0';
      Ctrl.MASTER.START_COMMAND <= '0';
      Ctrl.MASTER.INJ_CRC_ERR <= '0';
      Ctrl.SLAVE.TX_RESET <= '0';
      Ctrl.SLAVE.RX_RESET <= '0';
      Ctrl.SLAVE.TX_WR <= '0';
      Ctrl.SLAVE.RX_RD <= '0';
      

      
      if localWrEn = '1' then
        case to_integer(unsigned(localAddress(5 downto 0))) is
        when 0 => --0x0
          Ctrl.MASTER.TX_RESET        <=  localWrData( 0);               
        when 1 => --0x1
          Ctrl.MASTER.RX_RESET        <=  localWrData( 1);               
        when 2 => --0x2
          reg_data( 2)( 0)            <=  localWrData( 0);                --Request a write config to the GBTx (IC)
          reg_data( 2)( 1)            <=  localWrData( 1);                --Request a read config to the GBTx (IC)
          reg_data( 2)(15 downto  8)  <=  localWrData(15 downto  8);      --I2C address of the GBTx
        when 6 => --0x6
          Ctrl.MASTER.TX_WR           <=  localWrData( 0);               
        when 7 => --0x7
          Ctrl.MASTER.RX_RD           <=  localWrData( 0);               
        when 22 => --0x16
          Ctrl.MASTER.START_RESET     <=  localWrData( 0);               
        when 23 => --0x17
          Ctrl.MASTER.START_CONNECT   <=  localWrData( 0);               
        when 24 => --0x18
          Ctrl.MASTER.START_COMMAND   <=  localWrData( 0);               
        when 25 => --0x19
          Ctrl.MASTER.INJ_CRC_ERR     <=  localWrData( 0);               
        when 21 => --0x15
          reg_data(21)( 2 downto  0)  <=  localWrData( 2 downto  0);      --Enable flag to select SCAs
        when 5 => --0x5
          reg_data( 5)( 7 downto  0)  <=  localWrData( 7 downto  0);      --Data to be written into the internal FIFO
        when 9 => --0x9
          reg_data( 9)( 7 downto  0)  <=  localWrData( 7 downto  0);      --Command: The Command field is present in the frames received by the SCA and indicates the operation to be performed. Meaning is specific to the channel.
          reg_data( 9)(15 downto  8)  <=  localWrData(15 downto  8);      --Command: It represents the packet destination address. The address is one-byte long. By default, the GBT-SCA use address 0x00.
          reg_data( 9)(23 downto 16)  <=  localWrData(23 downto 16);      --Command: Specifies the message identification number. The reply messages generated by the SCA have the same transaction identifier of the request message allowing to associate the transmitted commands with the corresponding replies, permitting the concurrent use of all the SCA channels.  It is not required that ID values are ordered. ID values 0x00 and 0xff are reserved for interrupt packets generated spontaneously by the SCA and should not be used in requests.
          reg_data( 9)(31 downto 24)  <=  localWrData(31 downto 24);      --Command: The channel field specifies the destination interface of the request message (ctrl/spi/gpio/i2c/jtag/adc/dac).
        when 3 => --0x3
          reg_data( 3)(31 downto 16)  <=  localWrData(31 downto 16);      --Address of the first register to be accessed
        when 4 => --0x4
          reg_data( 4)(31 downto 16)  <=  localWrData(31 downto 16);      --Number of words/bytes to be read (only for read transactions)
        when 10 => --0xa
          reg_data(10)(31 downto  0)  <=  localWrData(31 downto  0);      --Command: data field (According to the SCA manual)
        when 32 => --0x20
          Ctrl.SLAVE.TX_RESET         <=  localWrData( 0);               
        when 33 => --0x21
          Ctrl.SLAVE.RX_RESET         <=  localWrData( 1);               
        when 34 => --0x22
          reg_data(34)( 0)            <=  localWrData( 0);                --Request a write config to the GBTx (IC)
          reg_data(34)( 1)            <=  localWrData( 1);                --Request a read config to the GBTx (IC)
          reg_data(34)(15 downto  8)  <=  localWrData(15 downto  8);      --I2C address of the GBTx
        when 38 => --0x26
          Ctrl.SLAVE.TX_WR            <=  localWrData( 0);               
        when 39 => --0x27
          Ctrl.SLAVE.RX_RD            <=  localWrData( 0);               
        when 37 => --0x25
          reg_data(37)( 7 downto  0)  <=  localWrData( 7 downto  0);      --Data to be written into the internal FIFO
        when 35 => --0x23
          reg_data(35)(31 downto 16)  <=  localWrData(31 downto 16);      --Address of the first register to be accessed
        when 36 => --0x24
          reg_data(36)(31 downto 16)  <=  localWrData(31 downto 16);      --Number of words/bytes to be read (only for read transactions)

          when others => null;
        end case;
      end if;
    end if;
  end process reg_writes;


end architecture behavioral;